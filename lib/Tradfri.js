// Generated by CoffeeScript 2.2.2
(function() {
  var Accessory, Client, DEBUG, Group, NodeTradfri, Property, States, Tradfri, Types, sleep;

  NodeTradfri = require('node-tradfri-client');

  Client = NodeTradfri.TradfriClient;

  Types = NodeTradfri.AccessoryTypes;

  Accessory = require('./Accessory');

  Group = require('./Group');

  Property = require('./Property');

  DEBUG = false;

  States = Object.freeze({
    DISCONNECTED: Symbol('disconnected'),
    CONNECTING: Symbol('connecting'),
    CONNECTED: Symbol('connected')
  });

  sleep = function(time = 1) {
    return new Promise(function(resolve, reject) {
      return setTimeout(function() {
        return resolve();
      }, time * 1000);
    });
  };

  Tradfri = (function() {
    class Tradfri extends Property {
      // This should be called with either a securityId string
      // or an object containing the keys: identity & psk
      constructor(hub, securityId) {
        super();
        this.hub = hub;
        this.securityId = securityId;
        this.client = new Client(this.hub);
      }

      connect() {
        var credentials;
        credentials = void 0;
        return (typeof this.securityId === 'string' ? this.client.authenticate(this.securityId) : Promise.resolve({
          identity: this.securityId.identity,
          psk: this.securityId.psk
        })).then(async(result) => {
          credentials = result;
          switch (this.connectState) {
            case States.DISCONNECTED:
              this.connectState = States.CONNECTING;
              return this.client.connect(result.identity, result.psk).then((ans) => {
                if (!ans) {
                  throw new Error("Failed to connect");
                }
                this.client.on('error', (err) => {
                  return console.error(err); // Just log it to STDERR and carry on
                }).on("device updated", (device) => {
                  var newdev;
                  newdev = Accessory.update(device);
                  if (DEBUG) {
                    return console.log(`device updated: ${device.name}`);
                  }
                }).on("device removed", (device) => {
                  return Accessory.delete(device);
                }).on("group updated", (group) => {
                  Group.update(group);
                  if (DEBUG) {
                    return console.log(`group updated: ${group.name}`);
                  }
                }).on("group removed", (group) => {
                  return Group.delete(group);
                }).on("scene updated", (groupID, scene) => {
                  var group;
                  group = Group.byID(groupID);
                  if (DEBUG) {
                    console.log(`scene updated: ${group.name}: ${scene.name}`);
                  }
                  if (!group) {
                    throw new Error(`Missing group ${groupID}`);
                  }
                  return group.addScene(scene);
                }).on("scene removed", (groupID, scene) => {
                  var group;
                  group = Group.byID(groupID);
                  if (!group) {
                    throw new Error(`Missing group ${groupID}`);
                  }
                  return group.delScene(scene.instanceId);
                });
                return this.client.observeDevices();
              }).then(() => { // Need the devices in place so not Promise.all()
                if (DEBUG) {
                  console.log("observeDevices resolved");
                }
                return this.client.observeGroupsAndScenes();
              }).then(() => {
                if (DEBUG) {
                  console.log("observeGroupsAndScenes resolved");
                }
                this.connectState = States.CONNECTED;
                return credentials;
              });
            case States.CONNECTING:
              while (this.connectState !== States.CONNECTED) {
                await sleep(.25);
              }
              return credentials;
            case States.CONNECTED:
              return credentials;
          }
        });
      }

      reset() {
        return this.client.reset();
      }

      close() {
        this.client.destroy();
        Group.close();
        Accessory.close();
        return delete this.client;
      }

      device(name) {
        return Accessory.get(name);
      }

      group(name) {
        return Group.get(name);
      }

    };

    Tradfri.prototype.connectState = States.DISCONNECTED;

    return Tradfri;

  }).call(this);

  module.exports = Tradfri;

}).call(this);
